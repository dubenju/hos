汇编指令与机器码的相互转换

机器语言我们只要重点理解一下几个概念：

1. 机器语言指令有操作码(OP)和地址码两部分组成
|_____________OP_______________|__d__|__w__|
|_____________OP_______________|__s__|__w__| <--此格式用于立即寻址方式

在多数操作码中，常使用某些位来指示某些信息：
如图上结构里的： 
w＝1 时 对字来操作
w＝0 时 对字节来操作

d值在双操作数指令中才有效
当 d＝1 时 有且只有一个寄存器用于目的操作数
当d＝0 时 有且只有一个寄存器用于源操作数

s＝1 时 立即数为8位，但要求扩展成16位数
s＝0 时 当指令作字节操作/有16位立即数

由于汇编的指令格式很多，这里我只作一些基本情况介绍，
必要时读者可以下载/查阅80x86汇编小站http://www.x86asm.com提供的OPCODES手册来查阅。

2. 寻址方式的机器语言表示：
| mod | reg | r/m |
|_____|_____|_____|_____|_____|_____|_____|
reg 表示寄存器方式，
在不包括立即数的双操作数指令的情况下，规定必须有一个操作数在寄存器中，
该寄存器由reg字段指定，并与操作码字节中的w位相组合确定的寄存器
mod字段与r/m(register/memory)字段结合在一起确定另一个操作数的寻址方式
现在你们下载了80x86汇编小站(http://www.x86asm.com)提供的OPCODES 手册了吗？
下载好了，请解压后打开里面的：opcodes.html 文件，然后熟悉里面的表格：
 
现在熟悉简单的：
______________________________________________________________________________
表1 <PS:部分资料> rrr : W=0 : W=1 : reg32
000 : AL : AX : EAX
001 : CL : CX : ECX
010 : DL : DX : EDX
011 : BL : BX : EBX
100 : AH : SP : ESP
101 : CH : BP : EBP
110 : DH : SI : ESI
111 : BH : DI : EDI
______________________________________________________________________________
表2 <PS:部分资料> rrr : Index Register
000 : EAX
001 : ECX
010 : EDX
011 : EBX
100 : No Index
101 : EBP
110 : ESI
111 : EDI
______________________________________________________________________________
表3 <PS:部分资料> mmm : Function 11
w＝1
000 : DS:[BX+SI]
001 : DS:[BX+DI]
010 : SS:[BP+SI]
011 : SS:[BP+DI] BX
100 : DS:[SI]
101 : DS:[DI]
110 : SS:[BP]
111 : DS:[BX]
______________________________________________________________________________
表4 <PS:部分资料>
oo : Function
00 : If mmm = 110, then a displacement follows the operation; otherwise, no displacement is used
01 : An 8-bit signed displacement follows the opcode
10 : A 16-bit signed displacement follows the opcode
11 : mmm specifies a register, instead of an addressing mode
______________________________________________________________________________
上面的表，你都看明白了吗？ 现在我就教你们如何利用这样的表格来把汇编指令翻译机器码

3.指令格式简介
8086所用的16位指令格式：
________ _____________ ________ ________
|操作码| + |mod-reg-r/m| + |位移量| + |立即数|
1~2字节 0~1字节 0~2字节 0~2字节
OK!以上就是基本知识，下面我们来实践吧：
———————————————————————————————————————
问题：
MOV AX,1234H 对应的机器码为：B83412
MOV EBX,0 对应的机器码为：66BB00000000
MOV CL,55H 对应的机器码为: B155
 
MOV AX,BX 对应的机器码为：8BC3
我在问一下，机器码的数据格式是什么？ 好像是 机器指令+操作数(高位存放在地址高位，低位存放在地址低位)，但是前面MOV AX,怎么就变成了B8,弄不明白，请指教。
PS: 上面的题目是一个网友问的，现在我来实践一遍给你们看。
———————————————————————————————————————
指令1 －> MOV AX,1234H 对应的机器码为：B83412
解法： 判断－> 这个是8086汇编16位汇编指令格式，并且是立即寻址方式
查表－> 打开opcodes.html文件，找到标题为“Main Instructions”，单击“M”字母，然后对应查看 “MOV Reg,Imm”格式的“OpCode”项为：1011wrrr
再判断－> 由于寄存器是AX, 立即数是1234H，明显是“对字操作”，所以w＝1
在查看本文章上面的“表1”，对应的查到rrr的值为000
组合结果－> w＝1
rrr＝000
1011wrrr＝1011 1000B －>B8H
根据“ 3.指令格式简介” －> B8H + |立即数(低位在前高位在后)|＝ B83412H
PS: "+" 符号不为“加号”
好了，已经解完第一题了，机器码为 B83412H
———————————————————————————————————————
指令4 －> MOV AX,BX 对应的机器码为：8BC3
解法： 判断－> 这个是8086汇编16位汇编指令格式，并且是寄存器寻址方式
查表－> 打开opcodes.html文件，找到标题为“Main Instructions”，单击“M
”字母，然后对应查看 “MOV Reg,Reg”格式的“OpCode”项为：1000101woorrrmmm
再判断－> 由于寄存器是AX, BX 明显是“对字操作”，所以w＝1
在查看本文章上面的“表4”，对应查到oo＝11 因为是寄存器寻址方式
在查看本文章上面的“表1”，对应查到rrr的值为000 ，因为当两个操
作数都是寄存器，那么一般要以目的操作数为准
在查看本文章上面的“表3”, 对应查到mmm的值为011 ，因为当两个操作数都是寄存器，那么一般要以源操作数为准
组合结果－> w＝1
oo＝11
rrr＝000
mmm＝011
1000101woorrrmmm＝1000 1011 1100 0011B ->8BC3H
好了，已经解完第二题了，机器码为8BC3H
———————————————————————————————————————

呵呵，不错吧，很简单吧，有了80X86 OPCODES 查询表一切都是那么简单，如果还有什么问题，大家都来这里提问！
剩下的：
指令2 －> MOV EBX,0 对应的机器码为：66BB00000000
指令3 －> MOV CL,55H 对应的机器码为: B155
大家来练练手，注意指令2 需要用到32位指令格式，请查阅相关的80x86汇编语言书籍的机器语言部分，应该有解释的。
