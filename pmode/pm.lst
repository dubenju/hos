     1                                              org     0x7C00          ; 该命令表示程序将被装在到偏移地址为0x7C00的地方  
     2                                                                      ; 该命令效果是全局的，但只能使用一次，之后不得再用  
     3                                                                      ; 从该位置开始到整个源代码结束之间的所有标号在被访问时都会隐式地自动加上0x7C00  
     4                                                                      ; 但是和vstart=0x7C00不同，vstart会将整个段内所有指令的汇编地址都加上0x7C00  
     5                                                                      ; 而org不影响汇编地址，仅仅就是在访问标号的时候临时加一个0x7C00  
     6                                                                      ; 并将这个临时的和作为访问结果返回  
     7                                    
     8 00000000 EB26                                jmp     start  
     9                                    
    10                                  GDT_BEG: ; GDT表的定义  
    11 00000002 0000000000000000        DESC_SG_NULL    dd  0x00000000, 0x00000000  
    12 0000000A FF01007C009A4000        DESC_SG_CODE    dd  0x7C0001FF, 0x00409A00 ; TYPE=1010,代码段必须可读，否则msg中的内容是无法读出并写到显卡中的  
    13 00000012 FFFF00800B924000        DESC_SG_VIDEO   dd  0x8000FFFF, 0x0040920B  
    14 0000001A 007A000000964000        DESC_SG_STACK   dd  0x00007A00, 0x00409600  
    15                                  GDT_END:  
    16                                    
    17                                  ; 段选择子  
    18                                  SLCT_NULL       equ DESC_SG_NULL - GDT_BEG  
    19                                  SLCT_CODE       equ DESC_SG_CODE - GDT_BEG  
    20                                  SLCT_VIDEO      equ DESC_SG_VIDEO - GDT_BEG  
    21                                  SLCT_STACK      equ DESC_SG_STACK - GDT_BEG  
    22                                    
    23                                  ; GDT总共有多少个双字  
    24                                  GDT_SIZE_DWORD  equ (GDT_END - GDT_BEG) / 4  
    25                                    
    26                                  GDTR:   ; 以下48位内容需要加载到全局描述符表寄存器gdtr中  
    27 00000022 1F00                    GDT_BOUND       dw  GDT_END - GDT_BEG - 1   ; 低16位是GDT的界限（即GDT总共多少字节）  
    28                                                                              ; 如果把GDT看做以字节为单位的数组，则下标从0开始  
    29                                                                              ; 所以该项为GDT总字节数减1  
    30                                                                              ; 本程序总共有4个描述符，GDT每个表项都占8字节  
    31 00000024 007E0000                GDT_BASE        dd  0x7E00          ; GDT加载在内存中的起始物理地址  
    32                                                                      ; 由于在加载GDTR时还没有进入保护模式，因此只能用20位地址  
    33                                                                      ; 这里就只能用32位来表示20位地址了  
    34                                                                      ; 因此在进入保护模式前只能将GDT加载到1MB的内存空间中  
    35                                                                      ; 在进入保护模式之后可以再将GDT移动到其它位置  
    36                                                                      ; 由于MBR位于0x7C00开始的512字节空间中了  
    37                                                                      ; 因此就将GDT放在后面一个新的512字节处（7E00H = 7C00H + 512）  
    38                                    
    39                                  PORT_FAST_A20   equ 0x92            ; 快速设置A20地址线的端口  
    40                                  GATE_ALT_A20    equ 0x02            ; 开启A20地址线的位掩码（门控），也称作A20替代门控  
    41                                                                      ; 即该8位端口的1号位置1即可打开A20地址线  
    42                                    
    43                                  GATE_PE         equ 0x01            ; 控制寄存器（32位）的第0位——保护模式允许位（Protection Enable）  
    44                                                                      ; 也称作PE门控  
    45                                                                      ; 将其设置为1就真正进入保护模式了  
    46                                                                      ; 从此之后都要按照保护模式的规矩来了  
    47                                                                      ; 这是真正的保护模式的开关  
    48                                  ; 程序开始  
    49 00000028 8CC8                    start:      mov     ax, cs  
    50 0000002A 8ED0                                mov     ss, ax  
    51 0000002C BC007C                              mov     sp, 0x7C00  
    52                                    
    53                                              ; ds:si指向本代码中的临时GDT  
    54 0000002F 8CC8                                mov     ax, cs  
    55 00000031 8ED8                                mov     ds, ax  
    56 00000033 BE[0200]                            mov     si, GDT_BEG  
    57                                    
    58                                              ; es:di指向GDT实际加载的位置0x7E00:0  
    59 00000036 2EA1[2400]                          mov     ax, [cs: GDT_BASE]  
    60 0000003A 2E8B16[2600]                        mov     dx, [cs: GDT_BASE+2]  
    61 0000003F BB1000                              mov     bx, 16  
    62 00000042 F7F3                                div     bx                      ; 获取实际物理地址对应的16位段地址  
    63 00000044 8EC0                                mov     es, ax  
    64 00000046 BF0000                              mov     di, 0  
    65                                    
    66                                              ; 将GDT加载到指定位置  
    67 00000049 B90800                              mov     cx, GDT_SIZE_DWORD  
    68 0000004C FC                                  cld  
    69 0000004D F366A5                              rep     movsd  
    70                                    
    71 00000050 2E0F0116[2200]                      lgdt    [cs: GDTR]              ; load gdtr，将GDTR处的48位内容加载进gdtr中  
    72                                    
    73                                              ; 由于实模式下地址只有20位，为了使20位地址溢出时归0并产生进位CF就必须关闭  
    74                                              ; 第21根地址线即A20（Address #20），如果不关闭则20位地址溢出时的进位会  
    75                                              ; 出现在A20处而不产生CF进位标记，同时不能归0  
    76                                              ; 因此在进入32位保护模式之前必须先开启A20（实模式下A20不工作，即一直为0）  
    77                                              ; 从而使32位的每一位都能工作成为真正意义上的32位模式  
    78 00000056 E492                                in      al, PORT_FAST_A20  
    79 00000058 0C02                                or      al, GATE_ALT_A20  
    80 0000005A E692                                out     PORT_FAST_A20, al  
    81                                    
    82                                              ; 保护模式下段的定位和实模式不同  
    83                                              ; 因此在保护模式下所有BIOS中断都不能使用（跳转到中断例程时需要定位）  
    84                                              ; 因此在进入保护模式之后需要重新设置BIOS中断的定位  
    85                                              ; 因此在这个问题解决之前不能相应任何中断  
    86                                              ; 因此在进入保护模式之前到BIOS中断重新设置完毕的过程中必须要关中断以免发生未知异常  
    87 0000005C FA                                  cli         ; clear IF，将IF标志位（中断允许标志位）置0  
    88                                                          ; 对应的sti，即set IF，将IF位置1重新允许中断  
    89                                                          ; 由于本程序并不重新设置BIOS的定位，因此就无需sti  
    90                                    
    91 0000005D 0F20C0                              mov     eax, cr0            ; cr0是0号寄存器，还有cr1、cr2等  
    92 00000060 6683C801                            or      eax, GATE_PE        ; 彻底进入保护模式  
    93 00000064 0F22C0                              mov     cr0, eax  
    94                                    
    95                                              ; 虽然是进入了保护模式，但cs的描述符高速缓冲寄存器中的内容还是20位模式下的内容  
    96                                              ; 如果这个问题不解决会导致程序的错误，因此必须刷新cs  
    97                                              ; 刷新的同时也会自动更新描述符高速缓冲寄存器，同时清空了流水线  
    98                                              ; 只能通过转移、调用、返回、中断指令来修改cs  
    99 00000067 66EA[8984FFFF]0800                  jmp     dword SLCT_CODE:(pm32_start - 0x7C00)   ; 注意cs现在是段选择子  
   100                                                                                              ; 由于所有标号被引用的时候会加0x7C00  
   101                                                                                              ; 而段选择子中起始位置是从0x7C00开始算起的  
   102                                                                                              ; 所以在这里跳转的时候偏移地址需要减去0x7C00  
   103                                                                                              ; 使用dword主要是约束偏移地址，使之成为32位的  
   104                                                                                              ; 这之后就会使用eip作为偏移指针了  
   105 0000006F 416C72656164792069-         msg     db  'Already in protect mode...'  
   106 00000078 6E2070726F74656374-
   107 00000081 206D6F64652E2E2E   
   108                                      len_msg equ $-msg  
   109                                    
   110                                              [bits 32]  
   111                                  pm32_start:  
   112 00000089 B810000000                          mov     eax, SLCT_VIDEO             ; 段选择子  
   113 0000008E 8ED8                                mov     ds, eax  
   114                                    
   115                                              ; 显示msg  
   116 00000090 BB[6F84FFFF]                        mov     ebx, msg-0x7C00  
   117 00000095 BE00000000                          mov     esi, 0  
   118 0000009A BF00000000                          mov     edi, 0  
   119 0000009F 2E8A0433                    .lp:    mov     al, [cs: ebx+esi]  
   120 000000A3 8807                                mov     [edi], al  
   121 000000A5 46                                  inc     esi  
   122 000000A6 83C702                              add     edi, 2  
   123 000000A9 E2F4                                loop    .lp  
   124                                    
   125                                    
   126                                              ; 测试栈段  
   127 000000AB B818000000                          mov     eax, SLCT_STACK  
   128 000000B0 8ED0                                mov     ss, eax  
   129 000000B2 BC007C0000                          mov     esp, 0x7C00  
   130                                    
   131 000000B7 89E5                                mov     ebp, esp        ; 备份esp  
   132                                    
   133 000000B9 6A21                                push    byte '!'        ; 立即数压入实验  
   134 000000BB 83ED04                              sub     ebp, 4  
   135 000000BE 39E5                                cmp     ebp, esp        ; 考察一下压入的是否是32位数  
   136 000000C0 750D                                jne     .tail  
   137 000000C2 58                                  pop     eax             ; 事实证明32位模式下压入的立即数必定都是32为的  
   138 000000C3 A21A000000                          mov     [0x1A], al  
   139 000000C8 C6051C00000020                      mov     [0x1C], byte ' '     ; 抽马桶  
   140                                    
   141 000000CF EBFE                        .tail:  jmp     $  
   142                                    
   143 000000D1 00<rept>                times 510 - ($ - $$)    db  0  
   144 000001FE 55AA                                            dw  0xAA55  
   145                                  
