启动
System bootstrapping
On IBM PC-compatible computers, 
the bootstrapping firmware contained within the ROM BIOS loads and executes the master boot record.
The PC/XT (type 5160) used an Intel 8088 microprocessor.
In order to remain compatible, all x86 architecture systems start with the microprocessor in an operating mode referred to as real mode.
The BIOS reads the MBR from the storage device into physical memory,
and then it directs the microprocessor to the start of the boot code.
Since the BIOS runs in real mode, the processor is in real mode when the MBR program begins to execute,
and so the beginning of the MBR is expected to contain real mode machine language instructions.
Due to the restricted size of the MBR's code section,
it typically contains only a small program that copies additional code (such as a boot loader) from the storage device into memory.
Control is then passed to this code, which is responsible for loading the actual operating system.
This process is known as chain loading.
Popular MBR code programs were created for booting PC DOS and MS-DOS, and similar boot code remains in wide use.
These boot sectors expect the fdisk partition table scheme to be in use,
and scans the list of partitions in the MBR's embedded partition table to find the only one that is marked with the active flag.
It then loads and runs the volume boot record (VBR) of the active partition.
There are alternative boot code implementations,
some of which are installed by boot managers,
which operate in a variety of ways.
Some MBR code loads additional code for a boot manager from the first track of the disk,
which it assumes to be "free" space that is not allocated to any disk partition,
and executes it.
A MBR program may interact with the user to determine which partition on which drive should boot,
and may transfer control to the MBR of a different drive.
Other MBR code contains a list of disk locations (often corresponding to the contents of files in a filesystem) of the remainder of the boot manager code to load and to execute.
(The first relies on behavior that is not universal across all disk partitioning utilities, most notably those which read and write GPTs.
The last requires that the embedded list of disk locations be updated when changes are made that would relocate the remainder of the code.)
On machines that do not use x86 processors,
or on x86 machines with non-BIOS firmware such as Open Firmware or Extensible Firmware Interface (EFI) firmware,
this design is unsuitable,
and the MBR is not used as part of the system bootstrap.
EFI firmware is instead capable of directly understanding the GPT partitioning scheme and the FAT filesystem format,
and loads and runs programs held as files in the EFI System partition.
The MBR will be involved only insofar as it might contain a partition table for compatibility purposes if the GPT partition table scheme has been used.
There is some MBR replacement code that emulates EFI firmware's bootstrap,
which makes non-EFI machines capable of booting from disks using the GPT partitioning scheme.
It detects a GPT, places the processor in the correct operating mode,
and loads the EFI compatible code from disk to complete this task.

Programming considerations
The MBR originated in the PC XT.[32] IBM PC-compatible computers are little-endian, which means the processor stores numeric values spanning two or more bytes in memory least significant byte first. The format of the MBR on media reflects this convention. Thus, the MBR signature will appear in a disk editor as the sequence 55hex AAhex.[a]

The bootstrap sequence in the BIOS will load the first valid MBR that it finds into the computer's physical memory at address 0000hex:7C00hex.[32] The last instruction executed in the BIOS code will be a "jump" to that address, to direct execution to the beginning of the MBR copy. The primary validation for most BIOSes is the signature at offset +1FEhex, although a BIOS implementer may choose to include other checks, such as verifying that the MBR contains a valid partition table without entries referring to sectors beyond the reported capacity of the disk.

While the MBR boot sector code expects to be loaded at physical address 0000hex:7C00hex,[g] all the memory from physical address 0000hex:0501hex (address 0000hex:0500hex is the last one used by a Phoenix BIOS)[14] to 0000hex:7FFFhex,[32] later relaxed to 0000hex:FFFFhex[33] (and sometimes[h] up to 9000hex:FFFFhex)—​​the end of the first 640 KB—​​is available in real mode.[i] The INT 12h BIOS interrupt call may help in determining how much memory can be allocated safely (by default, it simply reads the base memory size in KB from segment:offset location 0040hex:0013hex, but it may be hooked by other resident pre-boot software like BIOS overlays, RPL code or viruses to reduce the reported amount of available memory in order to keep other boot stage software like boot sectors from overwriting them).

The last 66 bytes of the 512-byte MBR are reserved for the partition table and other information, so the MBR boot sector program must be small enough to fit within 446 bytes of memory or less. The MBR code may communicate with the user, examine the partition table. Eventually, the MBR will need to perform its main task, and load the program that will perform the next stage of the boot process, usually by making use of INT 13h BIOS calls. While it may be convenient to think of the MBR and the program that it loads as separate and discrete, a clear distinction between the MBR and the loaded OS is not technically required—the MBR, or parts of it,[j] could stay resident in RAM and be used as part of the loaded program, after the MBR transfers control to that program. The same is true of a volume boot record, whether that volume is a floppy disk or a fixed disk partition. However, in practice, it is typical for the program loaded by a boot record program to discard and overwrite the RAM image of the latter, so that its only function is as the first link of the boot loader chain.

From a technical standpoint, it is important to note that the distinction between an MBR and a volume boot record exists only at the user software level, above the BIOS firmware. (Here, the term "user software" refers to both operating system software and application software.) To the BIOS, removable (e.g. floppy) and fixed disks are essentially the same. For either, the BIOS reads the first physical sector of the media into RAM at absolute address 7C00hex, checks the signature in the last two bytes of the loaded sector, and then, if the correct signature is found, transfers control to the first byte of the sector with a jump (JMP) instruction. The only real distinction that the BIOS makes is that (by default, or if the boot order is not configurable) it attempts to boot from the first removable disk before trying to boot from the first fixed disk. From the perspective of the BIOS, the action of the MBR loading a volume boot record into RAM is exactly the same as the action of a floppy disk volume boot record loading the object code of an operating system loader into RAM. In either case, the program that BIOS loaded is going about the work of chain loading an operating system. The distinction between an MBR and a volume boot record is an OS software-level abstraction, designed to help people to understand the operational organization and structure of the system. That distinction doesn't exist for the BIOS. Whatever the BIOS directly loads, be it an MBR or a volume boot record, is given total control of the system, and the BIOS from that point is solely at the service of that program. The loaded program owns the machine (until the next reboot, at least). With its total control, this program is not required to ever call the BIOS again and may even shut BIOS down completely, by removing the BIOS ISR vectors from the processor interrupt vector table, and then overwrite the BIOS data area. This is mentioned to emphasize that the boot program that the BIOS loads and runs from the first sector of a disk can truly do anything, so long as the program does not call for BIOS services or allow BIOS ISRs to be invoked after it has disrupted the BIOS state necessary for those services and ISRs to function properly.

As stated above, the conventional MBR bootstrap code loads and runs (boot loader- or operating system-dependent) volume boot record code that is located at the beginning of the "active" partition. A conventional volume boot record will fit within a 512-byte sector, but it is safe for MBR code to load additional sectors to accommodate boot loaders longer than one sector, provided they do not make any assumptions on what the sector size is. In fact, at least 1 KB of RAM is available at address 7C00hex in every IBM XT- and AT-class machine, so a 1 KB sector could be used with no problem. Like the MBR, a volume boot record normally expects to be loaded at address 0000hex:7C00hex. This derives from the fact that the volume boot record design originated on unpartitioned media, where a volume boot record would be directly loaded by the BIOS boot procedure; as mentioned above, the BIOS treats MBRs and volume boot records (VBRs)[k] exactly alike. Since this is the same location where the MBR is loaded, one of the first tasks of an MBR is to relocate itself somewhere else in memory. The relocation address is determined by the MBR, but it is most often 0000hex:0600hex (for MS-DOS/PC DOS, OS/2 and Windows MBR code) or 0060hex:0000hex (most DR-DOS MBRs). (Even though both of these segmented addresses resolve to the same physical memory address in real mode, for Apple Darwin to boot, the MBR must be relocated to 0000hex:0600hex instead of 0060hex:0000hex, since the code depends on the DS:SI pointer to the partition entry provided by the MBR, but it erroneously refers to it via 0000hex:SI only.[34]) While the MBR code relocates itself it is still important not to relocate to other addresses in memory because many VBRs will assume a certain standard memory layout when loading their boot file.

The Status field in a partition table record is used to indicate an active partition. Standard-conformant MBRs will allow only one partition marked active and use this as part of a sanity-check to determine the existence of a valid partition table. They will display an error message, if more than one partition has been marked active. Some non-standard MBRs will not treat this as an error condition and just use the first marked partition in the row.

Traditionally, values other than 00hex (not active) and 80hex (active) were invalid and the bootstrap program would display an error message upon encountering them. However, the Plug and Play BIOS Specification and BIOS Boot Specification (BBS) allowed other devices to become bootable as well since 1994.[33][35] Consequently, with the introduction of MS-DOS 7.10 (Windows 95B) and higher, the MBR started to treat a set bit 7 as active flag and showed an error message for values 01hex..7Fhex only. It continued to treat the entry as physical drive unit to be used when loading the corresponding partition's VBR later on, thereby now also accepting other boot drives than 80hex as valid, however, MS-DOS did not make use of this extension by itself. Storing the actual physical drive number in the partition table does not normally cause backward compatibility problems, since the value will differ from 80hex only on drives other than the first one (which have not been bootable before, anyway). However, even with systems enabled to boot off other drives, the extension may still not work universally, for example, after the BIOS assignment of physical drives has changed, for example when drives are removed, added or swapped. Therefore, per the BIOS Boot Specification (BBS),[33] it is best practice for a modern MBR accepting bit 7 as active flag to pass on the DL value originally provided by the BIOS instead of using the entry in the partition table.
BIOS to MBR interface
The MBR is loaded at memory location 0000hex:7C00hex and with the following CPU registers set up when the prior bootstrap loader (normally the IPL in the BIOS) passes execution to it by jumping to 0000hex:7C00hex in the CPU's real mode.

CS:IP = 0000hex:7C00hex (fixed)
Some Compaq BIOSes erroneously use 07C0hex:0000hex instead. While this resolves to the same location in real mode memory, it is non-standard and should be avoided, since MBR code assuming certain register values or not written to be relocatable may not work otherwise.
DL = boot drive unit (fixed disks / removable drives: 80hex = first, 81hex = second, ..., FEhex; floppies / superfloppies: 00hex = first, 01hex = second, ..., 7Ehex; values 7Fhex and FFhex are reserved for ROM / remote drives and must not be used on disk).
DL is supported by IBM BIOSes as well as most other BIOSes. The Toshiba T1000 BIOS is known to not support this properly, and some old Wyse 286 BIOSes use DL values greater or equal to 2 for fixed disks (thereby reflecting the logical drive numbers under DOS rather than the physical drive numbers of the BIOS). USB sticks configured as removable drives typically get an assignment of DL = 80hex, 81hex, etc. However, some rare BIOSes erroneously presented them under DL = 01hex, just as if they were configured as superfloppies.
A standard conformant BIOS assigns numbers greater or equal to 80hex exclusively to fixed disk / removable drives, and traditionally only values 80hex and 00hex were passed on as physical drive units during boot. By convention, only fixed disks / removable drives are partitioned, therefore, the only DL value a MBR could see traditionally was 80hex. Many MBRs were coded to ignore the DL value and work with a hard-wired value (normally 80hex), anyway.
The Plug and Play BIOS Specification and BIOS Boot Specification (BBS) allow other devices to become bootable as well since 1994.[33][35] The later recommends that MBR and VBR code should use DL rather than internally hardwired defaults.[33] This will also ensure compatibility with various non-standard assignments (see examples above), as far as the MBR code is concerned.
Bootable CD-ROMs following the El Torito specification may contain disk images mounted by the BIOS to occur as floppy or superfloppies on this interface. DL values of 00hex and 01hex may also be used by Protected Area Run Time Interface Extension Services (PARTIES) and Trusted Computing Group (TCG) BIOS extensions in Trusted mode to access otherwise invisible PARTIES partitions, disk image files located via the Boot Engineering Extension Record (BEER) in the last physical sector of a hard disk's Host Protected Area (HPA). While designed to emulate floppies or superfloppies, MBR code accepting these non-standard DL values allows to use images of partitioned media at least in the boot stage of operating systems.
DH bit 5 = 0: device supported through INT 13h; else: don't care (should be zero). DH is supported by some IBM BIOSes.
Some of the other registers may typically also hold certain register values (DS, ES, SS = 0000hex; SP = 0400hex) with original IBM ROM BIOSes, but this is nothing to rely on, as other BIOSes may use other values. For this reason, MBR code by IBM, Microsoft, Digital Research, etc. never did take any advantage of it. Relying on these register values in boot sectors may also cause problems in chain-boot scenarios.
Systems with Plug-and-Play BIOS or BBS support will provide a pointer to PnP data in addition to DL:[33][35]

DL = boot drive unit (see above)
ES:DI = points to "$PnP" installation check structure
This information allows the boot loader in the MBR (or VBR, if passed on) to actively interact with the BIOS or a resident PnP / BBS BIOS overlay in memory in order to configure the boot order, etc., however, this information is ignored by most standard MBRs and VBRs. Ideally, ES:DI is passed on to the VBR for later use by the loaded operating system, but PnP-enabled operating systems typically also have fallback methods to retrieve the PnP BIOS entry point later on so that most operating systems do not rely on this.
MBR to VBR interface
By convention, a standard conformant MBR passes execution to a successfully loaded VBR, loaded at memory location 0000hex:7C00hex, by jumping to 0000hex:7C00hex in the CPU's real mode with the following registers maintained or specifically set up:

CS:IP = 0000hex:7C00hex[l] (constant)
DL = boot drive unit (see above)
MS-DOS 2.0-7.0 / PC DOS 2.0-6.3 MBRs do not pass on the DL value received on entry, but they rather use the boot status entry in the partition table entry of the selected primary partition as physical boot drive unit. Since this is, by convention, 80hex in most MBR partition tables, it won't change things unless the BIOS attempted to boot off a physical device other than the first fixed disk / removable drive in the row. This is also the reason why these operating systems cannot boot off a second hard disk, etc. Some FDISK tools allow to mark partitions on secondary disks as "active" as well. In this situation, knowing that these operating systems cannot boot off other drives anyway, some of them continue to use the traditionally fixed value of 80hex as active marker, whereas others use values corresponding with the currently assigned physical drive unit (81hex, 82hex), thereby allowing to boot off other drives at least in theory. In fact, this will work with many MBR codes, which take a set bit 7 of the boot status entry as active flag rather than insisting on 80hex, however, MS-DOS/PC DOS MBRs are hard-wired to accept the fixed value of 80hex only. Storing the actual physical drive number in the partition table will also cause problems, when the BIOS assignment of physical drives changes, for example when drives are removed, added or swapped. Therefore, for a normal MBR accepting bit 7 as active flag and otherwise just using and passing on to the VBR the DL value originally provided by the BIOS allows for maximum flexibility. MS-DOS 7.1 - 8.0 MBRs have changed to treat bit 7 as active flag and any values 01hex..7Fhex as invalid, but they still take the physical drive unit from the partition table rather than using the DL value provided by the BIOS. DR-DOS 7.07 extended MBRs treat bit 7 as active flag and use and pass on the BIOS DL value by default (including non-standard values 00hex..01hex used by some BIOSes also for partitioned media), but they also provide a special NEWLDR configuration block in order to support alternative boot methods in conjunction with LOADER and REAL/32 as well as to change the detail behaviour of the MBR, so that it can also work with drive values retrieved from the partition table (important in conjunction with LOADER and AAPs, see NEWLDR offset +00Chex), translate Wyse non-standard drive units 02hex..7Fhex to 80hex..FDhex, and optionally fix up the drive value (stored at offset +19hex in the Extended BIOS Parameter Block (EBPB) or at sector offset +1FDhex ) in loaded VBRs before passing execution to them (see NEWLDR offset +014hex)—this also allows other boot loaders to use NEWLDR as a chain-loader, configure its in-memory image on the fly and "tunnel" the loading of VBRs, EBRs, or AAPs through NEWLDR.
The contents of DH and ES:DI should be preserved by the MBR for full Plug-and-Play support (see above), however, many MBRs, including those of MS-DOS 2.0 - 8.0 / PC DOS 2.0 - 6.3 and Windows NT/2000/XP, do not. (This is unsurprising, since those versions of DOS predate the Plug-and-Play BIOS standard, and previous standards and conventions indicated no requirements to preserve any register other than DL.) Some MBRs set DH to 0.
The MBR code passes additional information to the VBR in many implementations:

DS:SI = points to the 16-byte MBR partition table entry (in the relocated MBR) corresponding with the activated VBR. PC-MOS 5.1 depends on this to boot if no partition in the partition table is flagged as bootable. In conjunction with LOADER, Multiuser DOS and REAL/32 boot sectors use this to locate the boot sector of the active partition (or another bootstrap loader like IBMBIO.LDR at a fixed position on disk) if the boot file (LOADER.SYS) could not be found. PTS-DOS 6.6 and S/DOS 1.0 use this in conjunction with their Advanced Active Partition (AAP) feature. In addition to support for LOADER and AAPs, DR-DOS 7.07 can use this to determine the necessary INT 13h access method when using its dual CHS/LBA VBR code and it will update the boot drive / status flag field in the partition entry according to the effectively used DL value. Darwin bootloaders (Apple's boot1h, boot1u, and David Elliott's boot1fat32) depend on this pointer as well, but additionally they don't use DS, but assume it to be set to 0000hex instead.[34] This will cause problems if this assumption is incorrect. The MBR code of OS/2, MS-DOS 2.0 to 8.0, PC DOS 2.0 to 7.10 and Windows NT/2000/XP provides this same interface as well, although these systems do not use it. The Windows Vista/7 MBRs no longer provide this DS:SI pointer. While some extensions only depend on the 16-byte partition table entry itself, other extensions may require the whole 4 (or 5 entry) partition table to be present as well.
DS:BP = optionally points to the 16-byte MBR partition table entry (in the relocated MBR) corresponding with the activated VBR. This is identical to the pointer provided by DS:SI (see above) and is provided by MS-DOS 2.0-8.0, PC DOS 2.0-7.10, Windows NT/2000/XP/Vista/7 MBRs. It is, however, not supported by most third-party MBRs.
Under DR-DOS 7.07 an extended interface may be optionally provided by the extended MBR and in conjunction with LOADER:

AX = magic signature indicating the presence of this NEWLDR extension (0EDChex)
DL = boot drive unit (see above)
DS:SI = points to the 16-byte MBR partition table entry used (see above)
ES:BX = start of boot sector or NEWLDR sector image (typically 7C00hex)
CX = reserved
In conjunction with GPT, an Enhanced Disk Drive Specification (EDD) 4 Hybrid MBR proposal recommends another extension to the interface:[36]

EAX = 54504721hex ("!GPT")
DL = boot drive unit (see above)
DS:SI = points to a Hybrid MBR handover structure, consisting of a 16-byte dummy MBR partition table entry (with all bits set except for the boot flag at offset +0hex and the partition type at offset +4hex) followed by additional data. This is partially compatible with the older DS:SI extension discussed above, if only the 16-byte partition entry, not the whole partition table is required by these older extensions.
Since older operating systems (including their VBRs) do not support this extension nor are they able to address sectors beyond the 2 TiB barrier, a GPT-enabled hybrid boot loader should still emulate the 16-byte dummy MBR partition table entry if the boot partition is located within the first 2 TiB.[m]
ES:DI = points to "$PnP" installation check structure (see above)
