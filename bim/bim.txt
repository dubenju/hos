[ .bimファイルの構造 ]

+ 0 : .textサイズ
+ 4 : ファイル中の.textスタートアドレス（0x24）
+ 8 : メモリロード時の.textスタートアドレス（0x24）
+12 : .dataサイズ
+16 : ファイル中の.dataスタートアドレス
+20 : メモリロード時の.dataスタートアドレス
+24 : エントリポイント
+28 : bss領域のバイト数
+36 : コード


おおざっぱな説明

オブジェクトファイルを必要に応じてリンクして、未解決リンクのない単一のバイナリファイルを作るツール。つまりはリンカってことなのかな。
この段階ではまともなヘッダがないため、このままでは役に立たない。必要に応じてbim2hrbやbim2bin等を使ってヘッダをつける。
このツールの代わりにldを使うことはできるかもしれないが、その場合出てくるものは.bimファイルとは明らかにフォーマットが違うので、その差異は解決しなければならない（asmhead.nasやOS内のアプリファイル読み込み部分を改造する必要があるかもしれない）。
obj2bimは.objファイルを指定してもリンクする必要がないと判断すればリンクしない。そこがldとは違う（ldのリンク規則はややこしくてよく理解する気になれない）。
↑
やや細かい説明

obj2bimはtekの自動解凍機能を内蔵しているため、ライブラリやオブジェクトファイルをtek圧縮しておいても問題なくリンクできる。このためライブラリを小さく圧縮してもっておくことが可能。
[ .bimファイルの構造（haribote.rulを使った場合） ]

+ 0 : .textサイズ
+ 4 : ファイル中の.textスタートアドレス（0x24 = 36）
+ 8 : メモリロード時の.textスタートアドレス（0x24 = 36）
+12 : .dataサイズ
+16 : ファイル中の.dataスタートアドレス
+20 : メモリロード時の.dataスタートアドレス
+24 : エントリポイント
+28 : bss領域のバイト数
+36 : コード

haribote.rul内のフォーマット指定部

format:
    /* このセクションでリンクの方針を記述 */
    code(align:1, logic:0x24,      file:0x24);
    data(align:4, logic:stack_end, file:code_end);

logicというのは、メモリに読み込まれたときの番地のこと。この番地の値を参考にリンクが行われる。
   ORGみたいなものだと思うといいかもしれない。
fileというのは、.bimファイル内での位置のこと。
[ .bimファイルの構造（guigui00.rulを使った場合：つまりOSASKアプリ） ]

+ 0 : .textサイズ
+ 4 : ファイル中の.textスタートアドレス（0x48 = 72）
+ 8 : メモリロード時の.textスタートアドレス（0x48 = 72）
+12 : .dataサイズ
+16 : ファイル中の.dataスタートアドレス
+20 : メモリロード時の.dataスタートアドレス
+24 : エントリポイント
+28 : bss領域のバイト数
+36 : あき
+72 : コード

guigui00.rul内のフォーマット指定部

format:
    /* このセクションでリンクの方針を記述 */
    code(align:1, logic:0x48,      file:0x48);
    data(align:4, logic:stack_end, file:code_end);
↑
ldでobj2bimの代わりをさせたい

どうやるの？
.bimを直接作ることはできないと思うので、ldでの出力を.elfとか.peとか、もしくは.ldo（ld_output）とかにして、elf2hrbなどを自作する必要があると思います。
もしくは出てきたelfなどをアプリとしてOSが直接実行するのもいいかもしれません。
やりたい人はがんばってください。Kはがんばりたくないのでobj2bimとbim2hrbを作って使いました（OSを作りたいのであって、凝ったリンカを作ったり他人のリンカで悩まされたりするのが目的じゃなかったので）。
気が向いたらいつかやってみるかもしれません。
↑
こめんと欄
.hrb形式実行可能ファイルのリンカスクリプトの.hrbヘッダセクション定義を以下の.bimヘッダセクション定義に置き換えると、GNU/ldで直接.bim形式ファイルが作成できますよ。
SECTIONS {
   /* 
    * .bimのヘッダ
    */
    .head 0x0 : 
    {      
        /*
         * GNU ld version 2.14.90.0.7 20031029では、以下は、なぜか'+ 0'が必要。
         * LOADADDR(.text)
         * ADDR(.text)
         * ADDR(.data)
         * LONG(ADDR(.data))
         * HariStartup
        */
        LONG(SIZEOF(.text))       /* + 0 : .textサイズ */
        LONG(LOADADDR(.text) + 0) /* + 4 : ファイル中の.textスタートアドレス（0x24） */
        LONG(ADDR(.text) + 0)     /* + 8 : メモリロード時の.textスタートアドレス（0x24） */
        LONG(SIZEOF(.data))       /* +12 : .dataサイズ */
        LONG(LOADADDR(.data))     /* +16 : ファイル中の.dataスタートアドレス */
        LONG(ADDR(.data) + 0)     /* +20 : メモリロード時の.dataスタートアドレス */
        LONG(HariStartup + 0)     /* +24 : エントリポイント */
        LONG(SIZEOF(.bss))        /* +28 : bss領域のバイト数 */
        LONG(0x0)
    }
}
touch 2007-03-21 (水) 17:08:08
おおこれは興味深い！ありがとうございました。 -- K 2007-03-23 (金) 10:57:43
touchさんのLDスクリプトを参考に、C++サポート（コンストラクタ、仮想関数など）を利用するためのスクリプトを書きました。bimをすっ飛ばして実行形式（.hrbに相当）を生成するスクリプトです。今のところ、純粋仮想関数、仮想関数、グローバル変数に対するコンストラクタ（.ctors）など上手く動作しています。ただし、リンク後のファイル構造は.hrbファイルと.nosファイルは少し違います（主に.ctorsサポートのため。） https://gist.github.com/uchan-nos/8216363 -- uchan 2014-01-02 (木) 17:24:12
